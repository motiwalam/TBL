-- take a list of n initial values;
-- return a function f(x) which is f(x - 1) + f(x - 2) ... + f(x - n);
-- if x >= n, other wise return the x'th element from the list of initial;
-- values;
genfib: l $ (
    f: n $ 
        n < len @ [l] ? [
            get @ [l, n % (len @ [l])],
            reduce @ [
                add,
                map @ [
                    i $ (f @ [n - i]),
                    range @ [1, len @ [l]]
                ]
            ]
        ]
    ;
);

-- the classical fibonacci sequence;
fib: genfib @ [[0, 1]];
-- the lucas sequence;
lucas: genfib @ [[2, 1]];

-- n-nacci numbers, that is where the first n-1 values are 0 and the n-th initial value is 1;
nfib: n $ (genfib @ [concat @ [repeat @ [0, n-1], [1]]]);

-- tribonacci numbers;
trib: nfib @ 3;
-- tetranacci numbers;
tetra: nfib @ 4;

-- non recursive method;
fib: n $ (
    a: [0];
    b: [1];

    map @ [
        i $ (
            c: pop @ [a];
            d: pop @ [b];
            push @ [a, d];
            push @ [b, c + d];
        ),
        range @ [1, n]
    ];

    pop @ [b];
);

